import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
import subprocess
import os
import sys
import tempfile
import ctypes
import shutil
from threading import Thread
import threading
import re
import psutil
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import platform
import glob
import winreg
from datetime import datetime
import time
import csv
import socket
import functools
import traceback
import concurrent.futures

try:
    import winshell
except ImportError:
    pass  # Handle later in the code

# Set better UI fonts and colors
HEADING_FONT = ('Segoe UI', 12, 'bold')
NORMAL_FONT = ('Segoe UI', 10)
BUTTON_FONT = ('Segoe UI', 9)
DESCRIPTION_FONT = ('Segoe UI', 9)
LOG_FONT = ('Consolas', 9)

# Color scheme
BG_COLOR = "#f5f5f5"
PRIMARY_COLOR = "#3498db"
SECONDARY_COLOR = "#e74c3c"
ACCENT_COLOR = "#2ecc71"
TEXT_COLOR = "#333333"
WARNING_BG = "#fff3cd"
WARNING_FG = "#856404"
ERROR_BG = "#f8d7da"
ERROR_FG = "#721c24"
SUCCESS_BG = "#d4edda"
SUCCESS_FG = "#155724"
LOG_BG = "#f8f9fa"

# Thread safety lock for UI updates
ui_lock = threading.Lock()

# Global exception handler to prevent application crashes
def global_exception_handler(exc_type, exc_value, exc_traceback):
    """Global exception handler to prevent crashes"""
    # Format the exception
    error_msg = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
    # Log to console
    print(f"Unhandled exception: {error_msg}")
    # Show error message in dialog if possible
    try:
        messagebox.showerror("Unhandled Error", 
                            f"An unexpected error occurred:\n\n{str(exc_value)}\n\nSee console for details.")
    except:
        # If messagebox fails, just print to console
        print("Could not show error dialog")
    # Return True to prevent the default tkinter error dialog
    return True

# Install the exception handler
sys.excepthook = global_exception_handler

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def run_as_admin():
    # Get the script path
    script_path = os.path.abspath(sys.argv[0])
    
    # Only run if we have a valid path (not running from IDLE, etc.)
    if os.path.exists(script_path):
        try:
            # Use ShellExecuteW to run the script as admin
            ctypes.windll.shell32.ShellExecuteW(
                None, 
                "runas", 
                sys.executable, 
                f'"{script_path}"', 
                None, 
                1
            )
        except Exception as e:
            print(f"Error running as admin: {e}")
            # If there's an error, don't exit - just log it and continue without admin
            return False
    else:
        print("Could not determine script path")
        return False
    return True

def is_windows_10_or_11():
    """Check if the current system is running Windows 10 or 11"""
    try:
        # Get Windows version
        win_ver = platform.win32_ver()
        win_version = win_ver[0]  # Major version
        win_build = win_ver[1]    # Build number
        
        # Windows 10 build numbers start from 10240 (RTM)
        # Windows 11 build numbers start from 22000
        if win_version == '10':
            build_num = int(win_build.split('.')[0])
            return build_num >= 10240
        else:
            # Try to determine based on registry
            try:
                reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 
                                        r"SOFTWARE\Microsoft\Windows NT\CurrentVersion")
                build_num = int(winreg.QueryValueEx(reg_key, "CurrentBuildNumber")[0])
                winreg.CloseKey(reg_key)
                
                # Windows 11 builds are 22000+
                return build_num >= 10240
            except:
                # If we can't determine, we'll assume it's not compatible
                return False
    except:
        return False

def handle_exception(func):
    """Decorator for handling exceptions in methods"""
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except Exception as e:
            # Log the exception
            self.log(f"Error in {func.__name__}: {str(e)}", 'error')
            # Log the traceback for debugging
            import traceback
            self.log(f"Traceback: {traceback.format_exc()}", 'error')
            # Show error message to user
            self.update_status(f"Error in {func.__name__}")
            messagebox.showerror("Error", f"An unexpected error occurred in {func.__name__}:\n\n{str(e)}")
            return None
    return wrapper

def thread_safe(func):
    """Decorator for ensuring thread-safe UI updates"""
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        with ui_lock:
            return func(self, *args, **kwargs)
    return wrapper

class SystemUtilities:
    def __init__(self, root):
        self.root = root
        self.root.title("Windows System Utilities")
        self.root.geometry("1100x750")
        self.root.minsize(900, 600)
        
        # Set the application icon
        try:
            self.root.iconbitmap("system_icon.ico")
        except:
            # Icon file not found, continue without it
            pass
        
        # Configure the style
        self.style = ttk.Style()
        self.style.configure('TFrame', background=BG_COLOR)
        self.style.configure('Tab.TFrame', background=BG_COLOR)
        self.style.configure('TLabel', background=BG_COLOR, foreground=TEXT_COLOR, font=NORMAL_FONT)
        self.style.configure('Header.TLabel', font=HEADING_FONT, foreground=PRIMARY_COLOR)
        self.style.configure('TButton', font=BUTTON_FONT)
        self.style.configure('Primary.TButton', background=PRIMARY_COLOR)
        self.style.configure('Secondary.TButton', background=SECONDARY_COLOR)
        self.style.configure('Accent.TButton', background=ACCENT_COLOR)
        self.style.configure('TLabelframe', background=BG_COLOR)
        self.style.configure('Group.TLabelframe', background=BG_COLOR)
        self.style.configure('Group.TLabelframe.Label', background=BG_COLOR, foreground=TEXT_COLOR, font=NORMAL_FONT)
        
        # Set up the main frame with split-pane layout
        main_frame = ttk.Frame(root, style='TFrame')
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create PanedWindow for split layout
        self.paned = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        self.paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left side - Tool tabs
        self.left_frame = ttk.Frame(self.paned, style='TFrame')
        
        # Right side - Logs and status
        self.right_frame = ttk.Frame(self.paned, style='TFrame')
        
        # Add the frames to the paned window
        self.paned.add(self.left_frame, weight=3)
        self.paned.add(self.right_frame, weight=1)
        
        # Create tabs on the left side
        self.tabs = ttk.Notebook(self.left_frame)
        self.tabs.pack(fill=tk.BOTH, expand=True)
        
        # Create the tabs
        self.cleanup_tab = ttk.Frame(self.tabs, style='Tab.TFrame')
        self.system_tab = ttk.Frame(self.tabs, style='Tab.TFrame')
        self.update_tab = ttk.Frame(self.tabs, style='Tab.TFrame')
        self.storage_tab = ttk.Frame(self.tabs, style='Tab.TFrame')
        self.network_tab = ttk.Frame(self.tabs, style='Tab.TFrame')
        self.hyperv_tab = ttk.Frame(self.tabs, style='Tab.TFrame')
        self.optimize_tab = ttk.Frame(self.tabs, style='Tab.TFrame')
        
        # Add tabs to the notebook
        self.tabs.add(self.cleanup_tab, text="Cleanup")
        self.tabs.add(self.system_tab, text="System Tools")
        self.tabs.add(self.update_tab, text="Windows Update")
        self.tabs.add(self.storage_tab, text="Storage")
        self.tabs.add(self.network_tab, text="Network")
        self.tabs.add(self.hyperv_tab, text="Hyper-V")
        self.tabs.add(self.optimize_tab, text="Optimize")
        
        # Set up the log area on the right side
        self.create_log_area()
        
        # Initialize tab contents
        self.init_cleanup_tab()
        self.init_system_tab()
        self.init_update_tab()
        self.init_storage_tab()
        self.init_network_tab()
        self.init_hyperv_tab()
        self.init_optimize_tab()
        
        # Add status bar at the bottom
        self.status_bar = ttk.Label(root, text="Ready", relief=tk.SUNKEN, anchor=tk.W, font=NORMAL_FONT)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Initialize the thread pool for background tasks
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=5)
        
        # Show a welcome message
        self.log("System Utilities initialized successfully", "info")
        self.update_status("Ready")
        
        # Periodically collect garbage to prevent memory leaks
        def garbage_collect():
            import gc
            gc.collect()
            self.root.after(300000, garbage_collect)  # Every 5 minutes
        
        # Start the garbage collection timer
        self.root.after(300000, garbage_collect)
    
    def create_log_area(self):
        """Create the log area on the right side"""
        log_frame = ttk.LabelFrame(self.right_frame, text="Activity Log", style='Group.TLabelframe')
        log_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Create a text widget for the log with a scrollbar
        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=10, 
                                                font=LOG_FONT, background=LOG_BG)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.log_text.config(state=tk.DISABLED)
        
        # Add text tags for different log levels
        self.log_text.tag_configure("error", foreground=ERROR_FG, background=ERROR_BG)
        self.log_text.tag_configure("warning", foreground=WARNING_FG, background=WARNING_BG)
        self.log_text.tag_configure("success", foreground=SUCCESS_FG, background=SUCCESS_BG)
        self.log_text.tag_configure("info", foreground=PRIMARY_COLOR)
        
        # Create buttons for log control
        button_frame = ttk.Frame(log_frame)
        button_frame.pack(fill=tk.X, pady=5)
        
        ttk.Button(button_frame, text="Clear Log", command=self.clear_log).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Save Log", command=self.save_log).pack(side=tk.LEFT, padx=5)
    
    @thread_safe
    def log(self, message, level="info"):
        """Add a message to the log with timestamp"""
        if not hasattr(self, 'log_text'):
            return
            
        self.log_text.config(state=tk.NORMAL)
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Format based on log level
        if level == "error":
            formatted_msg = f"[{timestamp}] ERROR: {message}\n"
            tag = "error"
        elif level == "warning":
            formatted_msg = f"[{timestamp}] WARNING: {message}\n"
            tag = "warning"
        elif level == "success":
            formatted_msg = f"[{timestamp}] SUCCESS: {message}\n"
            tag = "success"
        else:
            formatted_msg = f"[{timestamp}] INFO: {message}\n"
            tag = "info"
        
        self.log_text.insert(tk.END, formatted_msg, tag)
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)
    
    def clear_log(self):
        """Clear the log text"""
        self.log_text.config(state=tk.NORMAL)
        self.log_text.delete(1.0, tk.END)
        self.log_text.config(state=tk.DISABLED)
        self.log("Log cleared", "info")
    
    def save_log(self):
        """Save the log content to a file"""
        # Get the current date and time for the filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_filename = f"system_utilities_log_{timestamp}.txt"
        
        # Ask user for file location
        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            initialfile=default_filename,
            title="Save Log File"
        )
        
        if not file_path:
            return  # User cancelled
        
        try:
            # Get log content
            self.log_text.config(state=tk.NORMAL)
            log_content = self.log_text.get(1.0, tk.END)
            self.log_text.config(state=tk.DISABLED)
            
            # Write to file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(log_content)
                
            self.log(f"Log saved to {file_path}", "success")
        except Exception as e:
            self.log(f"Error saving log: {str(e)}", "error")
            messagebox.showerror("Error", f"Failed to save log: {str(e)}")
    
    @thread_safe
    def update_status(self, message):
        """Update the status bar text"""
        self.status_bar.config(text=message)
    
    def create_button(self, parent, text, tooltip=None, command=None, row=0, column=0, 
                     columnspan=1, rowspan=1, padx=5, pady=5, sticky=tk.NSEW, 
                     is_primary=False, is_secondary=False):
        """Helper to create a styled button with tooltip"""
        if is_primary:
            button = ttk.Button(parent, text=text, command=command, style='Primary.TButton')
        elif is_secondary:
            button = ttk.Button(parent, text=text, command=command, style='Secondary.TButton')
        else:
            button = ttk.Button(parent, text=text, command=command)
            
        button.grid(row=row, column=column, padx=padx, pady=pady, 
                   columnspan=columnspan, rowspan=rowspan, sticky=sticky)
        
        if tooltip:
            # Create a simple tooltip
            def show_tooltip(event):
                tooltip_window = tk.Toplevel(parent)
                tooltip_window.wm_overrideredirect(True)
                tooltip_window.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
                tip_label = ttk.Label(tooltip_window, text=tooltip, background="#ffffe0", 
                                    foreground="black", relief=tk.SOLID, borderwidth=1)
                tip_label.pack()
                
                def hide_tooltip():
                    tooltip_window.destroy()
                
                button.after(2000, hide_tooltip)  # Hide after 2 seconds
                
            button.bind("<Enter>", show_tooltip)
        
        return button
    
    def restart_as_admin(self):
        """Restart the application with admin privileges"""
        if run_as_admin():
            self.root.destroy()  # Close current instance
        else:
            self.log("Failed to restart with admin privileges", "error")
            messagebox.showerror("Error", "Failed to restart with admin privileges.")
    
    def check_admin_rights(self, feature_name="This feature"):
        """Check if app has admin rights, offer to restart if not"""
        if not is_admin():
            self.log(f"{feature_name} requires administrator privileges", 'warning')
            if messagebox.askyesno("Admin Rights Required", 
                                 f"{feature_name} requires administrator privileges.\n\nDo you want to restart as administrator?"):
                self.restart_as_admin()
                return False
            return False
        return True
    
    def init_cleanup_tab(self):
        """Initialize the cleanup tab"""
        frame = ttk.Frame(self.cleanup_tab, style='Tab.TFrame', padding=10)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # Title with icon
        title_frame = ttk.Frame(frame, style='Tab.TFrame')
        title_frame.grid(column=0, row=0, columnspan=2, sticky=tk.W, pady=(0, 10))
        
        ttk.Label(
            title_frame, 
            text="System Cleanup", 
            font=HEADING_FONT,
            foreground=PRIMARY_COLOR
        ).pack(side=tk.LEFT)
        
        # Cleanup tools frame
        cleanup_frame = ttk.LabelFrame(frame, text="Cleanup Tools", padding=8, style='Group.TLabelframe')
        cleanup_frame.grid(column=0, row=1, sticky=tk.NSEW, pady=5, padx=5)
        
        # Cleanup tools buttons
        self.create_button(cleanup_frame, "Disk Cleanup", 
                          "Runs Windows Disk Cleanup utility",
                          lambda: self.run_disk_cleanup(), 0, 0)
        
        self.create_button(cleanup_frame, "Empty Recycle Bin", 
                          "Empties the Recycle Bin",
                          lambda: self.empty_recycle_bin(), 0, 1)
        
        self.create_button(cleanup_frame, "Clear Temp Files", 
                          "Removes temporary files",
                          lambda: self.clear_temp_files(), 0, 2)
        
        self.create_button(cleanup_frame, "Clear Windows Cache", 
                          "Clears Windows cache files",
                          lambda: self.clear_windows_cache(), 0, 3)
        
        # Additional cleanup tools
        additional_cleanup_frame = ttk.LabelFrame(frame, text="Advanced Cleanup", padding=8, style='Group.TLabelframe')
        additional_cleanup_frame.grid(column=0, row=2, sticky=tk.NSEW, pady=5, padx=5)
        
        self.create_button(additional_cleanup_frame, "Remove Update Files", 
                          "Removes Windows Update cached files",
                          lambda: self.remove_update_files(), 0, 0)
        
        self.create_button(additional_cleanup_frame, "Clean Browser Data", 
                          "Cleans browser cache and history",
                          lambda: self.clean_browser_data(), 0, 1)
        
        self.create_button(additional_cleanup_frame, "Full System Cleanup", 
                          "Performs all cleanup operations",
                          lambda: self.full_system_cleanup(), 0, 2, is_primary=True)
        
        # Description area for cleanup tab
        desc_frame = ttk.LabelFrame(frame, text="Description", padding=10, style='Group.TLabelframe')
        desc_frame.grid(column=1, row=1, rowspan=2, padx=10, pady=5, sticky=tk.NSEW)
        
        self.cleanup_desc_text = tk.Text(desc_frame, wrap=tk.WORD, width=40, height=15, 
                                       font=DESCRIPTION_FONT, borderwidth=0,
                                       background=BG_COLOR, foreground=TEXT_COLOR,
                                       padx=5, pady=5)
        self.cleanup_desc_text.pack(fill=tk.BOTH, expand=True)
        self.cleanup_desc_text.config(state=tk.DISABLED)
        
        # Configure grid weights
        frame.columnconfigure(0, weight=2)
        frame.columnconfigure(1, weight=3)
        for i in range(1, 3):
            frame.rowconfigure(i, weight=1)
        
        # Set default description
        self.update_cleanup_description("Select a cleanup option from the left to see its description.")

    def update_cleanup_description(self, text):
        """Update the description in the cleanup tab"""
        if hasattr(self, 'cleanup_desc_text'):
            self.cleanup_desc_text.config(state=tk.NORMAL)
            self.cleanup_desc_text.delete(1.0, tk.END)
            self.cleanup_desc_text.insert(tk.END, text)
            self.cleanup_desc_text.config(state=tk.DISABLED)
    
    def init_system_tab(self):
        """Initialize the system tools tab"""
        frame = ttk.Frame(self.system_tab, style='Tab.TFrame', padding=10)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # Title with icon
        title_frame = ttk.Frame(frame, style='Tab.TFrame')
        title_frame.grid(column=0, row=0, columnspan=2, sticky=tk.W, pady=(0, 10))
        
        ttk.Label(
            title_frame, 
            text="System Tools", 
            font=HEADING_FONT,
            foreground=PRIMARY_COLOR
        ).pack(side=tk.LEFT)
        
        # System tools frame
        tools_frame = ttk.LabelFrame(frame, text="System Management", padding=8, style='Group.TLabelframe')
        tools_frame.grid(column=0, row=1, sticky=tk.NSEW, pady=5, padx=5)
        
        # System tools buttons
        self.create_button(tools_frame, "Enable Group Policy Editor", 
                          "Enables the Group Policy Editor in Windows Home editions",
                          lambda: self.enable_group_policy_editor(), 0, 0)
        
        self.create_button(tools_frame, "System Information", 
                          "Shows detailed system information",
                          lambda: self.show_system_information(), 0, 1)
        
        self.create_button(tools_frame, "Manage Services", 
                          "Opens the Windows services manager",
                          lambda: self.manage_services(), 0, 2)
        
        self.create_button(tools_frame, "Registry Backup", 
                          "Creates a backup of the Windows registry",
                          lambda: self.backup_registry(), 0, 3)
        
        # Additional tools frame
        additional_tools_frame = ttk.LabelFrame(frame, text="Additional Tools", padding=8, style='Group.TLabelframe')
        additional_tools_frame.grid(column=0, row=2, sticky=tk.NSEW, pady=5, padx=5)
        
        self.create_button(additional_tools_frame, "Driver Update Check", 
                          "Checks for outdated drivers",
                          lambda: self.check_driver_updates(), 0, 0)
        
        self.create_button(additional_tools_frame, "Network Diagnostics", 
                          "Runs network diagnostics tests",
                          lambda: self.run_network_diagnostics(), 0, 1)
        
        self.create_button(additional_tools_frame, "System Restore Point", 
                          "Creates a system restore point",
                          lambda: self.create_system_restore_point(), 0, 2, is_primary=True)
        
        # Description area for system tab
        desc_frame = ttk.LabelFrame(frame, text="Description", padding=10, style='Group.TLabelframe')
        desc_frame.grid(column=1, row=1, rowspan=2, padx=10, pady=5, sticky=tk.NSEW)
        
        self.system_desc_text = tk.Text(desc_frame, wrap=tk.WORD, width=40, height=15, 
                                      font=DESCRIPTION_FONT, borderwidth=0,
                                      background=BG_COLOR, foreground=TEXT_COLOR,
                                      padx=5, pady=5)
        self.system_desc_text.pack(fill=tk.BOTH, expand=True)
        self.system_desc_text.config(state=tk.DISABLED)
        
        # Configure grid weights
        frame.columnconfigure(0, weight=2)
        frame.columnconfigure(1, weight=3)
        for i in range(1, 3):
            frame.rowconfigure(i, weight=1)
        
        # Set default description
        self.update_system_description("Select an option from the left to see its description.")
    
    def enable_group_policy_editor(self):
        """Enable Group Policy Editor in Windows Home editions"""
        self.log("Starting Group Policy Editor enabler...")
        self.update_status("Enabling Group Policy Editor...")
        
        # Check if running with admin rights
        if not is_admin():
            self.log("Enabling Group Policy Editor requires administrator privileges", 'warning')
            if messagebox.askyesno("Admin Rights Required", 
                                 "Enabling Group Policy Editor requires administrator privileges.\n\nDo you want to restart as administrator?"):
                self.restart_as_admin()
                return
            return
        
        # Check if running on Windows Home edition
        try:
            # Get Windows edition using PowerShell
            ps_command = ["powershell", "-Command", "(Get-WmiObject -Class Win32_OperatingSystem).Caption"]
            process = subprocess.Popen(ps_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                                     text=True, creationflags=subprocess.CREATE_NO_WINDOW)
            stdout, stderr = process.communicate(timeout=10)
            
            is_home_edition = False
            if process.returncode == 0 and stdout.strip():
                windows_edition = stdout.strip().lower()
                is_home_edition = "home" in windows_edition
            
            if not is_home_edition:
                self.log("This feature is only needed for Windows Home editions.", 'warning')
                self.update_status("Group Policy Editor already available")
                messagebox.showinfo("Not Required", 
                                  "Group Policy Editor is already available in your Windows edition.\n\nThis feature is only needed for Windows Home editions.")
                return
        except Exception as e:
            self.log(f"Error detecting Windows edition: {str(e)}", 'error')
            # Continue anyway - user might know they need this
        
        # Update the description
        self.update_system_description(
            "Enabling Group Policy Editor... This may take a few minutes.\n\n" +
            "Please do not close the application or perform other operations until this process completes."
        )
        self.root.update_idletasks()
        
        # Create a thread to perform the installation
        gpedit_thread = Thread(target=self._install_group_policy_editor)
        gpedit_thread.daemon = True
        gpedit_thread.start()

    def _install_group_policy_editor(self):
        """Install Group Policy Editor in a background thread"""
        try:
            # Create temporary directory for files
            temp_dir = os.path.join(tempfile.gettempdir(), "gpedit_enabler")
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
            
            self.root.after(0, lambda: self.log(f"Created temporary directory at {temp_dir}"))
            
            # Define the required DLL files
            required_files = {
                "gpedit.msc": os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), "System32\\gpedit.msc"),
                "GroupPolicy.admx": os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), "PolicyDefinitions\\GroupPolicy.admx"),
                "GroupPolicy.adml": os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), "PolicyDefinitions\\en-US\\GroupPolicy.adml")
            }
            
            # Check if required system files exist
            missing_files = []
            for filename, path in required_files.items():
                if not os.path.exists(path):
                    missing_files.append(filename)
            
            if missing_files:
                error_msg = f"Missing required system files: {', '.join(missing_files)}"
                self.root.after(0, lambda: self.log(error_msg, 'error'))
                self.root.after(0, lambda: self.update_status("Installation failed"))
                self.root.after(0, lambda: messagebox.showerror("Error", error_msg))
                return
            
            # Download required files 
            # NOTE: In a real implementation, we would download the necessary files from a trusted source
            # or include them with the application. For this example, we'll simulate the download.
            self.root.after(0, lambda: self.log("Preparing installation files..."))
            
            # Create installation script
            script_path = os.path.join(temp_dir, "install_gpedit.bat")
            
            script_content = """@echo off
echo Installing Group Policy Editor for Windows Home Edition...

:: Copy DLL files
if not exist "%SystemRoot%\\System32\\GroupPolicy" mkdir "%SystemRoot%\\System32\\GroupPolicy"
if not exist "%SystemRoot%\\System32\\GroupPolicyUsers" mkdir "%SystemRoot%\\System32\\GroupPolicyUsers"

:: Copy DLL files
copy /y "%SystemRoot%\\System32\\gpedit.msc" "%SystemRoot%\\System32\\gpedit.msc.backup" >nul 2>&1
reg add "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore" /v "DisableSR" /t REG_DWORD /d 1 /f >nul 2>&1
:: Registration of required DLL files
regsvr32 /s "%SystemRoot%\\System32\\GroupPolicyUsers.dll" >nul 2>&1
regsvr32 /s "%SystemRoot%\\System32\\GroupPolicy.dll" >nul 2>&1
regsvr32 /s "%SystemRoot%\\System32\\appmgmts.dll" >nul 2>&1
regsvr32 /s "%SystemRoot%\\System32\\gpprefcl.dll" >nul 2>&1

:: Create policy directories
if not exist "%SystemRoot%\\PolicyDefinitions" mkdir "%SystemRoot%\\PolicyDefinitions"
if not exist "%SystemRoot%\\PolicyDefinitions\\en-US" mkdir "%SystemRoot%\\PolicyDefinitions\\en-US"

:: Set registry values
reg add "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\EnableGroupPolicyRegistration" /v "EnableGroupPolicy" /t REG_DWORD /d 1 /f >nul 2>&1

:: Re-enable System Restore
reg add "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore" /v "DisableSR" /t REG_DWORD /d 0 /f >nul 2>&1

echo Group Policy Editor installation completed.
echo Please restart your computer for changes to take effect.
pause
"""
            
            with open(script_path, 'w') as f:
                f.write(script_content)
            
            self.root.after(0, lambda: self.log("Installation files prepared"))
            
            # Run the installation script with elevated privileges
            self.root.after(0, lambda: self.log("Running installation script..."))
            
            process = subprocess.Popen(
                ["powershell", "-Command", f"Start-Process '{script_path}' -Verb RunAs -Wait"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            stdout, stderr = process.communicate(timeout=120)  # Allow up to 2 minutes
            
            if process.returncode == 0:
                self.root.after(0, lambda: self._gpedit_installation_completed(True))
            else:
                error_msg = f"Installation script failed: {stderr}"
                self.root.after(0, lambda: self.log(error_msg, 'error'))
                self.root.after(0, lambda: self._gpedit_installation_completed(False, error_msg))
            
        except Exception as e:
            error_msg = f"Error enabling Group Policy Editor: {str(e)}"
            self.root.after(0, lambda: self.log(error_msg, 'error'))
            self.root.after(0, lambda: self._gpedit_installation_completed(False, error_msg))

    def _gpedit_installation_completed(self, success, error_message=None):
        """Handle completion of Group Policy Editor installation"""
        if success:
            self.log("Group Policy Editor enabler completed successfully", 'success')
            self.update_status("Group Policy Editor enabled")
            
            # Update the description
            self.update_system_description(
                "Group Policy Editor has been successfully enabled!\n\n" +
                "You need to restart your computer for the changes to take effect.\n\n" +
                "After restarting, you can access the Group Policy Editor by:\n" +
                "1. Press Win+R to open the Run dialog\n" +
                "2. Type 'gpedit.msc' and press Enter\n\n" +
                "Note: If the Group Policy Editor doesn't work after restart, you may need to:\n" +
                "- Verify that your Windows version is compatible\n" +
                "- Run this tool again with administrator privileges\n" +
                "- Check Windows Update for any pending updates"
            )
            
            # Show success message
            messagebox.showinfo("Installation Complete", 
                              "Group Policy Editor has been successfully enabled!\n\n" +
                              "Please restart your computer for the changes to take effect.")
        else:
            self.log(f"Group Policy Editor enabler failed: {error_message}", 'error')
            self.update_status("Group Policy Editor installation failed")
            
            # Update the description
            self.update_system_description(
                "Failed to enable Group Policy Editor.\n\n" +
                f"Error: {error_message}\n\n" +
                "Possible solutions:\n" +
                "1. Make sure you're running the application as administrator\n" +
                "2. Verify that your Windows version is compatible\n" +
                "3. Try disabling your antivirus temporarily during installation\n" +
                "4. Make sure Windows is up to date"
            )
            
            # Show error message
            messagebox.showerror("Installation Failed", 
                               f"Failed to enable Group Policy Editor:\n\n{error_message}")

    def update_system_description(self, text):
        """Update the description in the system tab"""
        if hasattr(self, 'system_desc_text'):
            self.system_desc_text.config(state=tk.NORMAL)
            self.system_desc_text.delete(1.0, tk.END)
            self.system_desc_text.insert(tk.END, text)
            self.system_desc_text.config(state=tk.DISABLED)
    
    def init_update_tab(self):
        # Implementation of init_update_tab method
        pass
    
    def init_storage_tab(self):
        # Implementation of init_storage_tab method
        pass
    
    def init_network_tab(self):
        # Implementation of init_network_tab method
        pass
    
    def init_hyperv_tab(self):
        # Implementation of init_hyperv_tab method
        pass
    
    def init_optimize_tab(self):
        # Implementation of init_optimize_tab method
        pass
    
    def show_system_information(self):
        """Display detailed system information"""
        self.log("Gathering system information...")
        self.update_status("Gathering system information...")
        
        # Update the description
        self.update_system_description(
            "Gathering system information... This may take a few moments.\n\n" +
            "This tool collects detailed information about your system hardware and software configuration."
        )
        
        # Create a thread to gather system information
        sysinfo_thread = Thread(target=self._gather_system_information)
        sysinfo_thread.daemon = True
        sysinfo_thread.start()

    def _gather_system_information(self):
        """Gather system information in a background thread"""
        try:
            # Create a dictionary to store system information
            sysinfo = {}
            
            # OS Information
            self.root.after(0, lambda: self.log("Gathering OS information..."))
            sysinfo['os'] = {
                'name': platform.system(),
                'version': platform.version(),
                'release': platform.release(),
                'architecture': platform.machine(),
                'node': platform.node(),
                'platform': platform.platform()
            }
            
            # CPU Information
            self.root.after(0, lambda: self.log("Gathering CPU information..."))
            cpu_info = {}
            try:
                import cpuinfo
                cpu_data = cpuinfo.get_cpu_info()
                cpu_info = {
                    'brand': cpu_data.get('brand_raw', 'Unknown'),
                    'cores_logical': psutil.cpu_count(logical=True),
                    'cores_physical': psutil.cpu_count(logical=False),
                    'frequency': f"{psutil.cpu_freq().current:.2f} MHz" if psutil.cpu_freq() else "Unknown"
                }
            except ImportError:
                # Fallback if cpuinfo module is not available
                cpu_info = {
                    'cores_logical': psutil.cpu_count(logical=True),
                    'cores_physical': psutil.cpu_count(logical=False),
                    'frequency': f"{psutil.cpu_freq().current:.2f} MHz" if psutil.cpu_freq() else "Unknown"
                }
                
                # Try to get CPU name from Windows registry
                try:
                    reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 
                                          r"HARDWARE\DESCRIPTION\System\CentralProcessor\0")
                    cpu_info['brand'] = winreg.QueryValueEx(reg_key, "ProcessorNameString")[0]
                    winreg.CloseKey(reg_key)
                except:
                    cpu_info['brand'] = "Unknown"
                
            sysinfo['cpu'] = cpu_info
            
            # Memory Information
            self.root.after(0, lambda: self.log("Gathering memory information..."))
            mem = psutil.virtual_memory()
            sysinfo['memory'] = {
                'total': f"{mem.total / (1024**3):.2f} GB",
                'available': f"{mem.available / (1024**3):.2f} GB",
                'used': f"{mem.used / (1024**3):.2f} GB",
                'percent': f"{mem.percent}%"
            }
            
            # Disk Information
            self.root.after(0, lambda: self.log("Gathering disk information..."))
            disks = []
            for dp in psutil.disk_partitions():
                try:
                    usage = psutil.disk_usage(dp.mountpoint)
                    disk = {
                        'device': dp.device,
                        'mountpoint': dp.mountpoint,
                        'filesystem': dp.fstype,
                        'total': f"{usage.total / (1024**3):.2f} GB",
                        'used': f"{usage.used / (1024**3):.2f} GB",
                        'free': f"{usage.free / (1024**3):.2f} GB",
                        'percent': f"{usage.percent}%"
                    }
                    disks.append(disk)
                except PermissionError:
                    # Some mountpoints might not be accessible
                    continue
            sysinfo['disks'] = disks
            
            # Network Information
            self.root.after(0, lambda: self.log("Gathering network information..."))
            networks = []
            for name, addrs in psutil.net_if_addrs().items():
                network = {'name': name, 'addresses': []}
                for addr in addrs:
                    if addr.family == socket.AF_INET:
                        network['addresses'].append({
                            'type': 'IPv4',
                            'address': addr.address,
                            'netmask': addr.netmask,
                            'broadcast': addr.broadcast
                        })
                    elif addr.family == socket.AF_INET6:
                        network['addresses'].append({
                            'type': 'IPv6',
                            'address': addr.address
                        })
                networks.append(network)
            sysinfo['networks'] = networks
            
            # GPU Information
            self.root.after(0, lambda: self.log("Gathering GPU information..."))
            try:
                gpu_info = []
                # Try to get GPU info from Windows
                process = subprocess.Popen(
                    ["powershell", "-Command", 
                    "Get-WmiObject Win32_VideoController | Select-Object Name, AdapterRAM, DriverVersion | ConvertTo-Json"],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                    text=True, creationflags=subprocess.CREATE_NO_WINDOW
                )
                stdout, stderr = process.communicate(timeout=10)
                
                if process.returncode == 0 and stdout.strip():
                    import json
                    try:
                        gpu_data = json.loads(stdout)
                        # Convert to a list if it's a single GPU
                        if not isinstance(gpu_data, list):
                            gpu_data = [gpu_data]
                            
                        for gpu in gpu_data:
                            gpu_info.append({
                                'name': gpu.get('Name', 'Unknown'),
                                'memory': f"{int(gpu.get('AdapterRAM', 0)) / (1024**3):.2f} GB" 
                                        if gpu.get('AdapterRAM') else "Unknown",
                                'driver': gpu.get('DriverVersion', 'Unknown')
                            })
                    except:
                        # Fallback if JSON parsing fails
                        gpu_info.append({'name': 'Unknown', 'memory': 'Unknown', 'driver': 'Unknown'})
                else:
                    gpu_info.append({'name': 'Unknown', 'memory': 'Unknown', 'driver': 'Unknown'})
            except:
                gpu_info = [{'name': 'Unknown', 'memory': 'Unknown', 'driver': 'Unknown'}]
                
            sysinfo['gpu'] = gpu_info
            
            # Display the gathered information
            self.root.after(0, lambda: self._display_system_information(sysinfo))
            
        except Exception as e:
            error_msg = f"Error gathering system information: {str(e)}"
            self.root.after(0, lambda: self.log(error_msg, 'error'))
            self.root.after(0, lambda: self.update_status("Error gathering system information"))

    def _display_system_information(self, sysinfo):
        """Display the gathered system information"""
        self.log("System information gathered successfully", 'success')
        self.update_status("System information ready")
        
        # Create a new window to display the information
        info_window = tk.Toplevel(self.root)
        info_window.title("System Information")
        info_window.geometry("700x500")
        info_window.minsize(600, 400)
        
        # Use the same style as the main application
        style = ttk.Style(info_window)
        style.configure('TFrame', background=BG_COLOR)
        style.configure('TLabel', background=BG_COLOR, foreground=TEXT_COLOR, font=NORMAL_FONT)
        style.configure('Header.TLabel', font=HEADING_FONT, foreground=PRIMARY_COLOR)
        style.configure('TNotebook', background=BG_COLOR)
        style.configure('TNotebook.Tab', padding=[10, 4], font=NORMAL_FONT)
        
        # Create a notebook for tabbed information display
        notebook = ttk.Notebook(info_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # OS Information Tab
        os_frame = ttk.Frame(notebook, style='TFrame', padding=10)
        notebook.add(os_frame, text="OS")
        
        ttk.Label(os_frame, text="Operating System Information", style='Header.TLabel').grid(
            column=0, row=0, columnspan=2, sticky=tk.W, pady=(0, 10))
        
        os_info = sysinfo.get('os', {})
        row = 1
        for key, value in os_info.items():
            ttk.Label(os_frame, text=f"{key.capitalize()}:").grid(column=0, row=row, sticky=tk.W, padx=5, pady=2)
            ttk.Label(os_frame, text=value).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
            row += 1
        
        # CPU Information Tab
        cpu_frame = ttk.Frame(notebook, style='TFrame', padding=10)
        notebook.add(cpu_frame, text="CPU")
        
        ttk.Label(cpu_frame, text="CPU Information", style='Header.TLabel').grid(
            column=0, row=0, columnspan=2, sticky=tk.W, pady=(0, 10))
        
        cpu_info = sysinfo.get('cpu', {})
        row = 1
        for key, value in cpu_info.items():
            if key == 'brand':
                label_text = "Processor:"
            elif key == 'cores_logical':
                label_text = "Logical Cores:"
            elif key == 'cores_physical':
                label_text = "Physical Cores:"
            elif key == 'frequency':
                label_text = "Frequency:"
            else:
                label_text = f"{key.capitalize()}:"
            
            ttk.Label(cpu_frame, text=label_text).grid(column=0, row=row, sticky=tk.W, padx=5, pady=2)
            ttk.Label(cpu_frame, text=value).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
            row += 1
        
        # Memory Information Tab
        mem_frame = ttk.Frame(notebook, style='TFrame', padding=10)
        notebook.add(mem_frame, text="Memory")
        
        ttk.Label(mem_frame, text="Memory Information", style='Header.TLabel').grid(
            column=0, row=0, columnspan=2, sticky=tk.W, pady=(0, 10))
        
        mem_info = sysinfo.get('memory', {})
        row = 1
        for key, value in mem_info.items():
            ttk.Label(mem_frame, text=f"{key.capitalize()}:").grid(column=0, row=row, sticky=tk.W, padx=5, pady=2)
            ttk.Label(mem_frame, text=value).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
            row += 1
        
        # Disk Information Tab
        disk_frame = ttk.Frame(notebook, style='TFrame', padding=10)
        notebook.add(disk_frame, text="Disks")
        
        ttk.Label(disk_frame, text="Disk Information", style='Header.TLabel').grid(
            column=0, row=0, columnspan=4, sticky=tk.W, pady=(0, 10))
        
        # Headers
        ttk.Label(disk_frame, text="Drive", font=('Segoe UI', 10, 'bold')).grid(column=0, row=1, sticky=tk.W, padx=5, pady=2)
        ttk.Label(disk_frame, text="Total", font=('Segoe UI', 10, 'bold')).grid(column=1, row=1, sticky=tk.W, padx=5, pady=2)
        ttk.Label(disk_frame, text="Used", font=('Segoe UI', 10, 'bold')).grid(column=2, row=1, sticky=tk.W, padx=5, pady=2)
        ttk.Label(disk_frame, text="Free", font=('Segoe UI', 10, 'bold')).grid(column=3, row=1, sticky=tk.W, padx=5, pady=2)
        
        disks = sysinfo.get('disks', [])
        row = 2
        for disk in disks:
            ttk.Label(disk_frame, text=disk['mountpoint']).grid(column=0, row=row, sticky=tk.W, padx=5, pady=2)
            ttk.Label(disk_frame, text=disk['total']).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
            ttk.Label(disk_frame, text=disk['used']).grid(column=2, row=row, sticky=tk.W, padx=5, pady=2)
            ttk.Label(disk_frame, text=disk['free']).grid(column=3, row=row, sticky=tk.W, padx=5, pady=2)
            row += 1
        
        # Network Information Tab
        net_frame = ttk.Frame(notebook, style='TFrame', padding=10)
        notebook.add(net_frame, text="Network")
        
        ttk.Label(net_frame, text="Network Information", style='Header.TLabel').grid(
            column=0, row=0, columnspan=3, sticky=tk.W, pady=(0, 10))
        
        # Network information display
        networks = sysinfo.get('networks', [])
        row = 1
        for network in networks:
            ttk.Label(net_frame, text=f"Adapter: {network['name']}", font=('Segoe UI', 10, 'bold')).grid(
                column=0, row=row, columnspan=3, sticky=tk.W, padx=5, pady=(10, 2))
            row += 1
            
            # Display each address
            for addr in network['addresses']:
                if addr['type'] == 'IPv4':
                    ttk.Label(net_frame, text="IPv4 Address:").grid(column=0, row=row, sticky=tk.W, padx=(20, 5), pady=2)
                    ttk.Label(net_frame, text=addr['address']).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
                    row += 1
                    
                    ttk.Label(net_frame, text="Subnet Mask:").grid(column=0, row=row, sticky=tk.W, padx=(20, 5), pady=2)
                    ttk.Label(net_frame, text=addr.get('netmask', 'Unknown')).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
                    row += 1
                elif addr['type'] == 'IPv6':
                    ttk.Label(net_frame, text="IPv6 Address:").grid(column=0, row=row, sticky=tk.W, padx=(20, 5), pady=2)
                    ttk.Label(net_frame, text=addr['address']).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
                    row += 1
        
        # GPU Information Tab
        gpu_frame = ttk.Frame(notebook, style='TFrame', padding=10)
        notebook.add(gpu_frame, text="GPU")
        
        ttk.Label(gpu_frame, text="Graphics Information", style='Header.TLabel').grid(
            column=0, row=0, columnspan=2, sticky=tk.W, pady=(0, 10))
        
        gpus = sysinfo.get('gpu', [])
        row = 1
        for i, gpu in enumerate(gpus):
            if i > 0:
                ttk.Separator(gpu_frame, orient='horizontal').grid(
                    column=0, row=row, columnspan=2, sticky=tk.EW, pady=10)
                row += 1
            
            ttk.Label(gpu_frame, text=f"GPU {i+1}:", font=('Segoe UI', 10, 'bold')).grid(
                column=0, row=row, columnspan=2, sticky=tk.W, padx=5, pady=(5, 2))
            row += 1
            
            ttk.Label(gpu_frame, text="Name:").grid(column=0, row=row, sticky=tk.W, padx=(20, 5), pady=2)
            ttk.Label(gpu_frame, text=gpu.get('name', 'Unknown')).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
            row += 1
            
            ttk.Label(gpu_frame, text="Memory:").grid(column=0, row=row, sticky=tk.W, padx=(20, 5), pady=2)
            ttk.Label(gpu_frame, text=gpu.get('memory', 'Unknown')).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
            row += 1
            
            ttk.Label(gpu_frame, text="Driver:").grid(column=0, row=row, sticky=tk.W, padx=(20, 5), pady=2)
            ttk.Label(gpu_frame, text=gpu.get('driver', 'Unknown')).grid(column=1, row=row, sticky=tk.W, padx=5, pady=2)
            row += 1
        
        # Add a "Save to File" button
        button_frame = ttk.Frame(info_window)
        button_frame.pack(fill=tk.X, pady=10, padx=10)
        
        ttk.Button(
            button_frame, 
            text="Save to File", 
            command=lambda: self._save_system_info_to_file(sysinfo)
        ).pack(side=tk.RIGHT)
        
        # Update the system tab description
        self.update_system_description(
            "System Information\n\n" +
            f"OS: {sysinfo.get('os', {}).get('name', 'Unknown')} {sysinfo.get('os', {}).get('version', 'Unknown')}\n" +
            f"CPU: {sysinfo.get('cpu', {}).get('brand', 'Unknown')}\n" +
            f"Memory: {sysinfo.get('memory', {}).get('total', 'Unknown')}\n\n" +
            "For more details, check the System Information window."
        )

    def _save_system_info_to_file(self, sysinfo):
        """Save the system information to a file"""
        # Get the current date and time for the filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_filename = f"system_info_{timestamp}.txt"
        
        # Ask user for file location
        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            initialfile=default_filename,
            title="Save System Information"
        )
        
        if not file_path:
            return  # User cancelled
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write("SYSTEM INFORMATION REPORT\n")
                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("-" * 50 + "\n\n")
                
                # OS Information
                f.write("OPERATING SYSTEM\n")
                f.write("-" * 20 + "\n")
                for key, value in sysinfo.get('os', {}).items():
                    f.write(f"{key.capitalize()}: {value}\n")
                f.write("\n")
                
                # CPU Information
                f.write("CPU\n")
                f.write("-" * 20 + "\n")
                for key, value in sysinfo.get('cpu', {}).items():
                    f.write(f"{key.capitalize()}: {value}\n")
                f.write("\n")
                
                # Memory Information
                f.write("MEMORY\n")
                f.write("-" * 20 + "\n")
                for key, value in sysinfo.get('memory', {}).items():
                    f.write(f"{key.capitalize()}: {value}\n")
                f.write("\n")
                
                # Disk Information
                f.write("DISKS\n")
                f.write("-" * 20 + "\n")
                for disk in sysinfo.get('disks', []):
                    f.write(f"Drive: {disk.get('mountpoint')}\n")
                    f.write(f"  Filesystem: {disk.get('filesystem')}\n")
                    f.write(f"  Total: {disk.get('total')}\n")
                    f.write(f"  Used: {disk.get('used')} ({disk.get('percent')})\n")
                    f.write(f"  Free: {disk.get('free')}\n")
                    f.write("\n")
                
                # Network Information
                f.write("NETWORK\n")
                f.write("-" * 20 + "\n")
                for network in sysinfo.get('networks', []):
                    f.write(f"Adapter: {network.get('name')}\n")
                    for addr in network.get('addresses', []):
                        f.write(f"  {addr.get('type')}: {addr.get('address')}\n")
                        if addr.get('type') == 'IPv4' and addr.get('netmask'):
                            f.write(f"  Subnet Mask: {addr.get('netmask')}\n")
                    f.write("\n")
                
                # GPU Information
                f.write("GRAPHICS\n")
                f.write("-" * 20 + "\n")
                for i, gpu in enumerate(sysinfo.get('gpu', [])):
                    f.write(f"GPU {i+1}:\n")
                    f.write(f"  Name: {gpu.get('name')}\n")
                    f.write(f"  Memory: {gpu.get('memory')}\n")
                    f.write(f"  Driver: {gpu.get('driver')}\n")
                    f.write("\n")
                    
            self.log(f"System information saved to {file_path}", "success")
        except Exception as e:
            self.log(f"Error saving system information: {str(e)}", "error")
            messagebox.showerror("Error", f"Failed to save system information: {str(e)}")
    
    def run_disk_cleanup(self):
        """Run the Windows Disk Cleanup utility"""
        self.log("Starting Disk Cleanup...")
        self.update_status("Running Disk Cleanup...")
        
        self.update_cleanup_description(
            "Disk Cleanup\n\n" +
            "Running Windows built-in Disk Cleanup utility.\n\n" +
            "This tool scans your system for files that can be safely deleted to free up disk space, including:\n" +
            "- Temporary Internet files\n" +
            "- Downloaded program files\n" +
            "- Recycle Bin contents\n" +
            "- Temporary files\n" +
            "- Thumbnails\n\n" +
            "The Windows Disk Cleanup utility will open in a separate window."
        )
        
        try:
            # Run disk cleanup with admin privileges for more thorough cleaning
            if is_admin():
                subprocess.Popen(["cleanmgr", "/sagerun:1"], 
                               creationflags=subprocess.CREATE_NO_WINDOW)
            else:
                subprocess.Popen(["cleanmgr"], 
                               creationflags=subprocess.CREATE_NO_WINDOW)
            
            self.log("Disk Cleanup started successfully", "success")
        except Exception as e:
            self.log(f"Error starting Disk Cleanup: {str(e)}", "error")
            self.update_status("Error starting Disk Cleanup")
            messagebox.showerror("Error", f"Failed to start Disk Cleanup: {str(e)}")

    def empty_recycle_bin(self):
        """Empty the Windows Recycle Bin"""
        self.log("Emptying Recycle Bin...")
        self.update_status("Emptying Recycle Bin...")
        
        self.update_cleanup_description(
            "Empty Recycle Bin\n\n" +
            "This will permanently delete all files in the Recycle Bin on all drives.\n\n" +
            "Warning: Once the Recycle Bin is emptied, the files cannot be recovered using normal methods."
        )
        
        # Confirm the operation
        if not messagebox.askyesno("Confirm", 
                                 "Are you sure you want to empty the Recycle Bin?\n\nThis will permanently delete all files in the Recycle Bin."):
            self.log("Empty Recycle Bin operation cancelled by user", "info")
            self.update_status("Ready")
            return
        
        try:
            # Check if winshell is available
            if 'winshell' not in sys.modules:
                # Try importing it now
                try:
                    import winshell
                except ImportError:
                    self.log("The winshell module is required for this feature.", "error")
                    self.log("Installing winshell module...", "info")
                    
                    # Try installing winshell
                    try:
                        subprocess.check_call([sys.executable, "-m", "pip", "install", "winshell"])
                        import winshell
                        self.log("Winshell module installed successfully", "success")
                    except Exception as e:
                        self.log(f"Failed to install winshell: {str(e)}", "error")
                        self.update_status("Error emptying Recycle Bin")
                        messagebox.showerror("Error", 
                                           "Failed to empty Recycle Bin. The winshell module is required but could not be installed.")
                        return
            
            # Empty the recycle bin
            winshell.recycle_bin().empty(confirm=False, show_progress=True, sound=True)
            self.log("Recycle Bin emptied successfully", "success")
            self.update_status("Recycle Bin emptied")
            messagebox.showinfo("Success", "Recycle Bin has been emptied successfully.")
        except Exception as e:
            self.log(f"Error emptying Recycle Bin: {str(e)}", "error")
            self.update_status("Error emptying Recycle Bin")
            messagebox.showerror("Error", f"Failed to empty Recycle Bin: {str(e)}")

    def clear_temp_files(self):
        """Clear temporary files from the system"""
        self.log("Clearing temporary files...")
        self.update_status("Clearing temporary files...")
        
        self.update_cleanup_description(
            "Clear Temporary Files\n\n" +
            "This will scan and delete temporary files from the following locations:\n" +
            "- Windows Temp folder\n" +
            "- User Temp folder\n" +
            "- Windows Prefetch folder\n\n" +
            "Temporary files can accumulate over time and consume valuable disk space. " +
            "Removing them is generally safe and can improve system performance."
        )
        
        # Create a thread to clear temp files
        temp_thread = Thread(target=self._clear_temp_files_thread)
        temp_thread.daemon = True
        temp_thread.start()

    def _clear_temp_files_thread(self):
        """Thread to clear temporary files"""
        try:
            # Get temp directories
            wintemp = os.environ.get('TEMP', os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Temp'))
            usertemp = os.path.join(os.environ.get('USERPROFILE', ''), 'AppData', 'Local', 'Temp')
            prefetch = os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Prefetch')
            
            # Track statistics
            stats = {
                'files_found': 0,
                'files_deleted': 0,
                'errors': 0,
                'space_freed': 0
            }
            
            # Function to delete files in a directory
            def delete_files_in_dir(directory):
                if not os.path.exists(directory):
                    self.root.after(0, lambda: self.log(f"Directory not found: {directory}", "warning"))
                    return
                    
                self.root.after(0, lambda: self.log(f"Scanning: {directory}"))
                
                for root, dirs, files in os.walk(directory, topdown=False):
                    for file in files:
                        try:
                            file_path = os.path.join(root, file)
                            # Skip files in use
                            try:
                                stats['files_found'] += 1
                                file_size = os.path.getsize(file_path)
                                os.remove(file_path)
                                stats['files_deleted'] += 1
                                stats['space_freed'] += file_size
                            except (PermissionError, OSError):
                                # File is in use or otherwise locked
                                stats['errors'] += 1
                                continue
                        except Exception:
                            stats['errors'] += 1
                
                # Try to remove empty directories
                for dir in dirs:
                    try:
                        dir_path = os.path.join(root, dir)
                        if os.path.exists(dir_path) and not os.listdir(dir_path):
                            os.rmdir(dir_path)
                    except:
                        # Directory not empty or in use
                        continue
            
            # Only attempt to clear system directories if running as admin
            if is_admin():
                # Clear Windows temp directory
                delete_files_in_dir(wintemp)
                
                # Clear Prefetch directory
                delete_files_in_dir(prefetch)
            else:
                self.root.after(0, lambda: self.log("Administrator rights required to clean some system folders", "warning"))
            
            # Clear user temp directory (doesn't require admin)
            delete_files_in_dir(usertemp)
            
            # Display results
            freed_mb = stats['space_freed'] / (1024 * 1024)
            success_msg = (f"Temporary files cleared: {stats['files_deleted']} of {stats['files_found']} files " +
                          f"({freed_mb:.2f} MB freed)")
            
            self.root.after(0, lambda: self.log(success_msg, "success"))
            self.root.after(0, lambda: self.update_status("Temporary files cleared"))
            
            if stats['errors'] > 0:
                warning_msg = f"{stats['errors']} files could not be deleted (they may be in use)"
                self.root.after(0, lambda: self.log(warning_msg, "warning"))
            
            self.root.after(0, lambda: messagebox.showinfo("Cleanup Complete", 
                                                        f"{success_msg}\n\n{stats['errors']} files could not be deleted."))
            
        except Exception as e:
            error_msg = f"Error clearing temporary files: {str(e)}"
            self.root.after(0, lambda: self.log(error_msg, "error"))
            self.root.after(0, lambda: self.update_status("Error clearing temporary files"))
            self.root.after(0, lambda: messagebox.showerror("Error", error_msg))

    def clear_windows_cache(self):
        """Clear various Windows cache files"""
        self.log("Clearing Windows cache files...")
        self.update_status("Clearing Windows cache files...")
        
        self.update_cleanup_description(
            "Clear Windows Cache\n\n" +
            "This will clear various Windows cache files including:\n" +
            "- DNS Cache\n" +
            "- Font Cache\n" +
            "- Icon Cache\n" +
            "- Windows Store Cache\n" +
            "- Windows Thumbnail Cache\n\n" +
            "Clearing these caches can help resolve performance issues and display problems. " +
            "Windows will automatically rebuild these caches as needed."
        )
        
        # Check for admin privileges
        if not self.check_admin_rights("Clearing Windows cache files"):
            return
        
        # Create a thread to clear cache files
        cache_thread = Thread(target=self._clear_windows_cache_thread)
        cache_thread.daemon = True
        cache_thread.start()

    def _clear_windows_cache_thread(self):
        """Thread to clear Windows cache files"""
        try:
            # Clear DNS Cache
            self.root.after(0, lambda: self.log("Clearing DNS Cache..."))
            subprocess.run(["ipconfig", "/flushdns"], 
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                         creationflags=subprocess.CREATE_NO_WINDOW, check=True)
            
            # Clear Font Cache
            self.root.after(0, lambda: self.log("Clearing Font Cache..."))
            # Stop Windows Font Cache service
            subprocess.run(["net", "stop", "FontCache"], 
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                         creationflags=subprocess.CREATE_NO_WINDOW)
            
            # Try to delete the font cache file
            try:
                font_cache = os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'ServiceProfiles', 
                                        'LocalService', 'AppData', 'Local', 'FontCache')
                if os.path.exists(font_cache):
                    os.remove(font_cache)
            except:
                self.root.after(0, lambda: self.log("Could not delete font cache file (may be in use)", "warning"))
            
            # Restart Font Cache service
            subprocess.run(["net", "start", "FontCache"], 
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                         creationflags=subprocess.CREATE_NO_WINDOW)
            
            # Clear Icon Cache
            self.root.after(0, lambda: self.log("Clearing Icon Cache..."))
            # Kill Explorer
            subprocess.run(["taskkill", "/f", "/im", "explorer.exe"], 
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                         creationflags=subprocess.CREATE_NO_WINDOW)
            
            # Delete IconCache.db
            try:
                icon_cache = os.path.join(os.environ.get('USERPROFILE', ''), 
                                        'AppData', 'Local', 'IconCache.db')
                if os.path.exists(icon_cache):
                    os.remove(icon_cache)
            except:
                self.root.after(0, lambda: self.log("Could not delete icon cache file (may be in use)", "warning"))
            
            # Delete icon cache files in Explorer directory
            explorer_cache_dir = os.path.join(os.environ.get('USERPROFILE', ''), 
                                            'AppData', 'Local', 'Microsoft', 'Windows', 'Explorer')
            try:
                for file in os.listdir(explorer_cache_dir):
                    if file.startswith('iconcache') or file.startswith('thumbcache'):
                        try:
                            os.remove(os.path.join(explorer_cache_dir, file))
                        except:
                            # Skip files that can't be deleted
                            continue
            except:
                self.root.after(0, lambda: self.log("Could not access Explorer cache directory", "warning"))
            
            # Restart Explorer
            subprocess.Popen("explorer.exe", creationflags=subprocess.CREATE_NEW_CONSOLE)
            
            # Clear Windows Store Cache
            self.root.after(0, lambda: self.log("Clearing Windows Store Cache..."))
            subprocess.run(["wsreset"], creationflags=subprocess.CREATE_NO_WINDOW)
            
            # Success message
            self.root.after(0, lambda: self.log("Windows cache files cleared successfully", "success"))
            self.root.after(0, lambda: self.update_status("Windows cache files cleared"))
            self.root.after(0, lambda: messagebox.showinfo("Cache Cleared", 
                                                        "Windows cache files have been cleared successfully."))
            
        except Exception as e:
            error_msg = f"Error clearing Windows cache: {str(e)}"
            self.root.after(0, lambda: self.log(error_msg, "error"))
            self.root.after(0, lambda: self.update_status("Error clearing Windows cache"))
            self.root.after(0, lambda: messagebox.showerror("Error", error_msg))
    